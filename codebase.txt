# Codebase Architecture and Communication Overview

## 1. Directory Structure

- **/src**: Main application source code.
  - **/app**: Next.js app directory (routing, layouts, API routes).
    - **/api**: API route handlers (REST/tRPC endpoints).
    - **/admin, /login, /success, /cancel, /(landing)**: App pages/routes.
    - **layout.tsx**: Root layout, applies global providers and styles.
  - **/modules**: Feature modules (auth, user, reservation, event, etc.). Each module contains its own API, business logic, and sometimes UI components.
  - **/deps**: Third-party integrations and wrappers (db, trpc, nodemailer, stripe, posthog, shadcn/ui, etc.).
  - **/utils**: Shared utility functions and React hooks.
  - **/constants**: Shared constants.
  - **/styles**: Global CSS and theme files.
  - **/global**: Global components (icon, spinner, wizard, etc.).
- **/prisma**: Database schema and migrations.
- **/public**: Static assets (images, etc.).

## 2. Architectural Principles

- **Modular Feature Design**: Each domain (user, reservation, event, etc.) is encapsulated in its own module under `src/modules`, with its own API, business logic, and sometimes UI.
- **API Layer (tRPC)**: All backend logic is exposed via tRPC routers, providing type-safe, end-to-end API communication between frontend and backend.
- **Database Access (Prisma)**: All persistent data access is handled via Prisma ORM, with a single shared client instance.
- **Context Propagation**: Global state (theme, viewport, analytics) is provided via React context providers at the root layout.
- **Third-party Integrations**: Email (Nodemailer), payments (Stripe), analytics (PostHog), and UI primitives (shadcn/ui, Radix, Geist) are wrapped in `/deps` for modularity.
- **Type Safety**: Zod is used for runtime validation, especially for environment variables and API inputs.

## 3. How Parts Communicate

### 3.1. API Communication (tRPC)
- **Frontend** calls backend procedures using the `api` object from `@/deps/trpc/react`, which is a tRPC React client.
- **tRPC React Provider** (`TRPCReactProvider` in `src/app/layout.tsx`) wraps the app, providing API hooks and query caching (via React Query).
- **API routes** (e.g., `src/app/api/trpc/[trpc]/route.ts`) forward requests to the tRPC handler, which dispatches to the appropriate router in `/modules`.
- **Routers** (e.g., `userRouter`, `authRouter`) are composed in `src/deps/trpc/root.ts` and expose module procedures (queries/mutations).
- **Procedures** use context (db, session) and call business logic, returning data to the frontend.

### 3.2. Database Access (Prisma)
- **Prisma Client** is instantiated in `src/deps/db/index.ts` and injected into tRPC context for all API calls.
- **Modules** access the database via `ctx.db` in their procedures.
- **Schema** is defined in `prisma/schema.prisma` and migrated via Prisma CLI.

### 3.3. Authentication & Session
- **Session Middleware** in `src/modules/auth/middleware/session-middleware.ts` injects user session into tRPC context for authed procedures.
- **Session management** (set, get, remove cookies) is handled in `src/modules/auth/api/session.ts` (not shown, but referenced).
- **Auth procedures** (login, logout, change password) are exposed via tRPC and use session middleware for access control.

### 3.4. UI & State Management
- **Global Providers**:
  - `ThemeProvider` (`src/modules/theme/providers/theme-provider.tsx`): Manages light/dark theme, persists in localStorage.
  - `ViewportSizeProvider` (`src/utils/use-viewport.tsx`): Tracks mobile/desktop viewport state.
  - `TRPCReactProvider`: Provides tRPC API and React Query context.
- **UI Components**:
  - **shadcn/ui**: Customizable UI primitives (button, modal, table, etc.) in `src/deps/shadcn/ui`.
  - **Radix UI**: Used for accessible dialogs, popovers, etc.
  - **Geist**: Font and design system.
  - **Global components**: Shared UI (icon, spinner, wizard) in `src/global/components`.
- **Pages**: Composed in `src/app`, using feature modules and global components.

### 3.5. Third-party Integrations
- **Nodemailer** (`src/deps/nodemailer/handler.ts`): Handles transactional email sending, using environment variables for SMTP config.
- **Stripe** (`src/deps/stripe/stripe.ts`): Handles payment processing, initialized with secret key from env.
- **PostHog** (`src/deps/posthog/index.tsx`): Analytics, only enabled in production, provides event capture hooks and provider.

### 3.6. Environment Variables
- Managed and validated via `@t3-oss/env-nextjs` and Zod in `src/env.js`.
- Split into server/client variables, injected at runtime.

## 4. Major Libraries and Their Roles

- **next**: React framework for SSR, routing, API routes.
- **react, react-dom**: UI rendering.
- **@trpc/server, @trpc/client, @trpc/react-query**: Type-safe API communication.
- **@tanstack/react-query**: Data fetching, caching, and synchronization.
- **prisma, @prisma/client**: ORM for PostgreSQL.
- **zod**: Runtime validation and type inference.
- **nodemailer**: Email sending.
- **stripe**: Payment processing.
- **posthog-js**: Analytics.
- **shadcn/ui, radix-ui**: UI primitives and accessibility.
- **geist**: Font and design system.
- **clsx, tailwind-merge**: Utility for className composition.
- **date-fns**: Date utilities.
- **bcrypt**: Password hashing.
- **superjson**: Serialization for tRPC.

## 5. Data Flow Example (User List)
1. **Frontend** calls `api.user.list.useQuery()`.
2. **tRPC React** sends request to `/api/trpc` route.
3. **tRPC handler** dispatches to `userRouter.list` procedure.
4. **Procedure** uses `ctx.db` (Prisma) to fetch users.
5. **Result** is returned to frontend, cached by React Query, and rendered in UI.

## 6. Summary
- The codebase is modular, type-safe, and leverages tRPC for seamless API communication.
- All business logic is encapsulated in feature modules, exposed via tRPC routers.
- Database access is centralized via Prisma and injected into API context.
- UI is composed of reusable primitives and global providers for theme, viewport, and API context.
- Third-party services are wrapped in `/deps` for easy replacement or extension.

--- CODEBASE REFACTORING PLAN ---



Okay, let's break down how to approach this refactor to meet your homework requirements, drawing heavily from the provided lecture materials and the professor's feedback.

The core issue is that your current Next.js/tRPC/Prisma stack, while modern and modular, is perceived by the professor as a "two-layer application." The goal is to introduce clear, distinct layers with an emphasis on dependency inversion, similar to the ProjectHEX example highlighted in the lectures (IS07, slides 48-55). This will allow for better separation of concerns and the ability to, for instance, swap out data persistence mechanisms with minimal changes, a key point mentioned by the professor.



Minimum Viable TypeScript Architecture
Based on the lectures, especially the Hexagonal Architecture (Ports and Adapters) demonstrated in ProjectHEX (IS07, slides 44-55)  and the principles of Clean Architecture or Onion Architecture (IS07, slides 23-27, 34), here's a target structure for your TypeScript project:





TypeScript

/src
├── domain // Core business logic and entities, independent of frameworks
│   ├── entities // Plain classes or interfaces representing your data
│   │   ├── sifrarnik.entity.ts
│   │   └── master.entity.ts
│   │   └── detail.entity.ts
│   ├── repositories // Interfaces (Ports) defining data access contracts
│   │   ├── isifrarnik.repository.ts
│   │   └── imaster.repository.ts
│   │   └── idetail.repository.ts
│   └── services // Domain services if complex logic spans multiple entities (optional for now)

├── application // Use cases, orchestrates domain objects and repositories
│   ├── services // Application services (Use Cases)
│   │   ├── sifrarnik.service.ts // Handles CRUD for Sifrarnik
│   │   └── master-detail.service.ts // Handles Master-Detail logic
│   ├── dtos // Data Transfer Objects for use case inputs/outputs (if needed)
│   └── validators // Business rule validation logic
│       ├── sifrarnik.validator.ts
│       └── master-detail.validator.ts

├── infrastructure // Concrete implementations of ports (Adapters)
│   ├── persistence // Data persistence adapters
│   │   └── prisma // Prisma-specific implementations
│   │       ├── prisma.sifrarnik.repository.ts
│   │       ├── prisma.master.repository.ts
│   │       ├── prisma.detail.repository.ts
│   │       └── prisma.client.ts // Your existing Prisma client
│   └── external-services // Adapters for email, payments etc. (not primary for homework)

├── presentation // Handles user interaction and API exposure (Next.js app & tRPC)
│   ├── api // Your tRPC routers and procedures (Primary/Driving Adapters)
│   │   ├── trpc // tRPC setup
│   │   │   ├── root.ts // Combine routers, inject application services
│   │   │   └── context.ts // tRPC context, DI happens here
│   │   └── routers
│   │       ├── sifrarnik.router.ts
│   │       └── master-detail.router.ts
│   ├── app // Next.js pages and UI components
│   │   ├── (sifrarnik)
│   │   │   └── page.tsx
│   │   ├── (master-detail)
│   │   │   └── page.tsx
│   │   └── components // Shared UI components
│   └── view-models // (Optional) Data structures tailored for views

└── main.ts // Or equivalent entry point for dependency injection (can be part of tRPC context)
Key Principles from Lectures Applied:

Dependency Inversion Principle (DIP): High-level modules (Application) should not depend on low-level modules (Infrastructure), but both should depend on abstractions (Domain interfaces/ports). (IS07, slide 24) 
Separation of Concerns: Each layer has a distinct responsibility.
Domain: Contains business entities and rules, completely unaware of UI, database, or other infrastructure. (IS07, slides 49-50 for ProjectHEX domain) 
Application: Orchestrates the domain to fulfill use cases. (IS07, slide 54 for ProjectHEX UseCases) 
Infrastructure: Implements interfaces defined in the domain/application layers for external concerns like databases, file systems, network calls. (IS07, slide 52 for ProjectHEX Adapters) 
Presentation: Interacts with the user (UI) or other systems (API endpoints) and delegates actions to the application layer.
Ports and Adapters (Hexagonal Architecture): The domain layer defines ports (repository interfaces). The infrastructure layer provides adapters (Prisma repository implementations). (IS07, slides 45-48) 

Layering (5-Layer Model as a Guideline):
Presentation Layer (UI/API): Your Next.js pages and tRPC routers. (IS07, slide 5) 
Workflow/Interface Control Layer: Could be part of your tRPC routers or Application Services. (IS07, slide 5) 
Business Rule Layer: Primarily in your domain entities and application services/validators. (IS07, slide 5) 
Data Layer (Data Access): infrastructure/persistence implementing domain repository interfaces. (IS07, slide 6) 
Data Storage Layer: Managed by Prisma. (IS07, slide 6) 
Quickest Approach to Transition for Homework
Given the tight deadline, focus on refactoring only the parts necessary for the homework: one "šifrarnik" (codebook/lookup table) CRUD screen and one master-detail screen.

Select Entities:

Šifrarnik: Choose a simple existing entity in your Prisma schema or create a new one (e.g., Role, Category, Status).
Master-Detail: Choose an existing relationship (e.g., Event as master, TicketType or Reservation as detail) or create a simplified version.
Implement the Domain Layer (for the selected entities):

Define interfaces for your entities in src/domain/entities. These can be simple TypeScript interfaces or classes.
Define repository interfaces (ports) in src/domain/repositories (e.g., ISifrarnikRepository.ts, IMasterRepository.ts). These will declare methods like findById, findAll, create, update, delete. (IS07, slide 51) 
Implement the Application Layer (for the selected features):

Create application services in src/application/services (e.g., SifrarnikService.ts).
These services will take repository interfaces (defined in the domain layer) as constructor dependencies (Dependency Injection). (IS07, slide 54, showing UseCases with repository dependencies) 
Implement the CRUD methods in these services, calling the respective repository methods.
Implement your "složenije pravilo" (complex validation rule) here or within a dedicated validator class called by the service. This rule should be more than just NOT NULL or basic type checking; for example, it could involve checking consistency between master and detail records, or a business rule that depends on the state of multiple fields or related entities. (IS03, slide 29; IS07, slide 28 )

Implement the Infrastructure Layer (Prisma Adapters):

In src/infrastructure/persistence/prisma, create concrete implementations of your repository interfaces (e.g., PrismaSifrarnikRepository.ts).
These classes will use your existing Prisma client to interact with the database. They implement the methods defined in the domain repository interfaces. (IS07, slide 52, shows MssqlRepository implementing IRepository) 
Refactor/Implement the Presentation Layer (tRPC & Next.js):

tRPC Routers: Modify your existing tRPC routers or create new ones in src/presentation/api/routers.
These routers will now depend on your application services instead of directly accessing Prisma.
Instantiate and inject application services into the tRPC router procedures, likely via the tRPC context.
Next.js Pages/Components: Create or adapt your React components in src/presentation/app for the šifrarnik and master-detail screens. These will use the tRPC client hooks to call your refactored tRPC procedures.
Implement the dropdown for foreign key selection in the master-detail form.
Dependency Injection (DI) / Inversion of Control (IoC):

The most straightforward place to handle DI for this setup is within your tRPC context creation (src/presentation/api/trpc/context.ts).
When creating the context for each request, instantiate your Prisma repository implementations and then instantiate your application services, injecting the repositories into them. The tRPC procedures will then access these pre-configured application services from the context.
This setup allows you to change the repository implementation (e.g., to a mock or a different database adapter) by changing only the instantiation logic in the context, demonstrating the swappability the professor wants to see. (IS07, slide 55, App.xaml.cs example) 
Testing (as per homework):

Presentation Layer Unit Tests: Test your tRPC router procedures. Mock the application services they call.
Application Layer Unit Tests: Test your application services. Mock the repository interfaces they depend on.
Data Access Layer Unit Tests (Infrastructure): Test your Prisma repository implementations. You might need to mock the Prisma client or use a test database setup. The lectures refer to testing each layer. (IS08, slides 40-50 )




Integration Tests: Create tests that call a tRPC endpoint and verify that it correctly interacts through the application service down to a mocked (or test instance of) repository, proving the layers are connected.
Documentation:

Create a component diagram. (IS07, slide 65-67 ) This diagram should show: 


Major layers: Presentation (API/UI), Application, Domain, Infrastructure.
Key components/modules within each layer (e.g., SifrarnikRouter, SifrarnikService, SifrarnikEntity, ISifrarnikRepository, PrismaSifrarnikRepository).
Dependencies between these components, highlighting the adherence to the dependency rule (arrows pointing inwards towards the domain).
Addressing Professor's Specific Points:
"MVC nije arhitektura, već arhitekturni obrazac na prezentacijskom sloju." This is correct. Your focus should be on the overall application layering, not just MVC in the frontend.
"Nas interesira uslojavanje aplikacije, prvenstveno prema 5-slojnoj arhitekturi, a onda možda rafiniranije prema Onion ili Vertical slice." The proposed architecture above aligns with Onion/Hexagonal, which is a refinement of layered principles and matches the ProjectHEX example. The 5-layer model (IS07, slides 4-7)  can be mapped: 

UI/Presentation + Interface Control: presentation layer.
Business: application services + domain entities/rules.
Data Access + Data Storage: infrastructure/persistence and Prisma itself.
"Sam po sebi Vertical slice ne znači ništa po pitanju ove zadaće, ako nije ispravno uslojen." While your current module structure might resemble vertical slices, the key is the internal layering within those features/slices. For the homework, apply the layered architecture to the specific features you implement.
"Za najbrži uvid u ono što se traži, pogledajte primjer ProjectHEX i uočite mogućnost zamjene baza podataka promjenom 1 linije kôda..." This is achieved by:
Defining repository interfaces (ports) in the domain layer.
Application services depending on these interfaces.
infrastructure layer providing concrete implementations (adapters) for these interfaces.
Using DI to inject the concrete adapter into the application service. Changing the database means providing a different adapter implementation at the DI setup point.
By focusing the refactor on the specific homework requirements and following the ProjectHEX structural patterns for those features, you should be able to meet the expectations within the given timeframe. The lectures provide ample examples of these architectural concepts (IS07).




---

TODO List for Refactor and Testing
----------------------------------
1. Install Vitest and related dependencies for testing (ts-node, @vitest/ui, @vitest/coverage-v8, etc.).
2. Write unit tests for CouponService in src/application/services/__tests__/coupon.service.test.ts (mock the repository).
3. Write unit tests for PrismaCouponRepository in src/infrastructure/persistence/prisma/__tests__/prisma.coupon.repository.test.ts (mock or use test db).
4. Refactor or create tRPC routers for Coupon to use the new CouponService from context.
5. Write unit/integration tests for the tRPC router (mock CouponService).
6. Adapt or create Next.js pages/components to use the new tRPC endpoints for Coupon.
7. Verify end-to-end functionality for the Coupon feature.
8. Repeat the same pattern for the Event-Reservation (master-detail) feature.
9. Write and update documentation, including a component diagram.
10. Update the Refactor Progress Log after each major step.

Refactor Progress Log
---------------------
- Refactor to Hexagonal/Onion architecture initiated. Planning to implement the Coupon (šifrarnik) and Event-Reservation (master-detail) features as the first vertical slices.
- Vitest and related dependencies installed using Bun as the package manager.
- Unit tests for CouponService created in src/application/services/__tests__/coupon.service.test.ts.
- Unit tests for PrismaCouponRepository created in src/infrastructure/persistence/prisma/__tests__/prisma.coupon.repository.test.ts.
- All Vitest unit tests for CouponService and PrismaCouponRepository passed successfully.
- Unit/integration tests for couponRouter created in src/presentation/api/routers/__tests__/coupon.router.test.ts.
- Note: The new couponRouter is currently tested in isolation with a custom context and is not yet integrated into the main app context due to context shape differences. Next step: adapt or create UI components to use the new endpoints for vertical slice progress.
- Added 'uses' field to the Coupon entity to match the DTO used in the UI and current API, enabling seamless adaptation of the UI to the new router.
- Refactored CouponsList and CouponRowActions to presentational components that accept data and mutation functions as props, enabling easy integration with the new tRPC client or any data source.
- Created CouponsListContainer to connect the presentational CouponsList to the new couponRouter endpoints using a mock context. This is a temporary integration layer until the new tRPC client is fully wired up.
- Created a new tRPC appRouter for the new architecture, combining the couponRouter. This will be used for the new API route and React client.
- Created a new Next.js API route for the new tRPC appRouter using fetchRequestHandler and the new context. Next integration step: align context shape between router and app for full end-to-end flow.
- Updated createContext to accept the request and return all required dependencies for the new router, aligning the context shape for the new API route and tRPC integration.
- Created a new tRPC React client for the new appRouter, enabling the UI to fetch and mutate real data through the new vertical slice.
- Refactored CouponsListContainer to use the new tRPC React client and real API. The Coupon feature is now fully integrated end-to-end in the new architecture.
- Started refactor of the Event-Reservation (master-detail) vertical slice using the same Hexagonal/Onion architecture approach as the Coupon feature.
- Created Event and Reservation entities, repositories, and services. The domain and application layers for the Event-Reservation vertical slice are now established.
- Implemented PrismaEventRepository and PrismaReservationRepository. The infrastructure layer for the Event-Reservation vertical slice is now established.
- Updated createContext to include eventService and reservationService, making them available to the new routers for the Event-Reservation vertical slice.
- Updated tRPC initialization to use the new context type globally, ensuring all routers and procedures are type-safe and consistent with the new architecture.

This documentation should help you understand how every part of the codebase communicates and how to approach a rewrite with a different structure. 

# Hexagonal/Onion Refactor Progress Log

## Completed Steps
- Unified tRPC context across the codebase to include all services and repositories (coupon, event, reservation) and Prisma client, matching the new architecture.
- Updated all tRPC routers (coupon, event, reservation) to use the correct context and import style, resolving context type mismatch errors.
- Ensured all routers are composed in the main appRouter.
- Fixed CouponsDashboardPage to use CouponsListContainer, resolving missing props error.
- The codebase now builds cleanly with no type or context errors.

## Next Steps
- Continue refactoring the rest of the codebase (other routers, services, UI, etc.) to the new architecture.
- Ensure all features are migrated to the new domain/application/infrastructure/presentation layering.
- Add/expand tests for new architecture.
- Update documentation as needed. 

## User Feature Refactor (Hexagonal/Onion)
- Created User entity in domain/entities/user.entity.ts
- Created IUserRepository in domain/repositories/iuser.repository.ts
- Implemented PrismaUserRepository in infrastructure/persistence/prisma/prisma.user.repository.ts
- Implemented UserService in application/services/user.service.ts
- Created userRouter in presentation/api/routers/user.router.ts
- Registered userRouter in appRouter (presentation/api/trpc/root.ts)
- Updated context to provide userRepository and userService
- Next: Refactor UI (UsersList, etc.) to use the new user API 

- [x] Refactored EventReservationsList to use new reservation API and re-enabled it in the UI.
- [x] Refactored CancelPage to use new reservation API and re-enabled it in the UI.
- [x] Refactored useEventReserveForm to use new reservation and coupon APIs.
- [x] Refactored EventPaymentStatusWizardStep to use new reservation API for payment status.
- [x] Refactored UsersList and useCreateUserForm to use new user API.
- [x] Fixed all linter/type errors in refactored files (EventReservationsList, CancelPage, useEventReserveForm, EventPaymentStatusWizardStep, UsersList, useCreateUserForm).
- [x] Add/expand unit tests for UserService, PrismaUserRepository, and userRouter (all tests created and passing).
- [x] Add/expand unit tests for EventService, PrismaEventRepository, and eventRouter (all tests created and passing).
- [ ] Add/expand unit tests for ReservationService, PrismaReservationRepository, and reservationRouter (next step).
- [ ] Add/expand unit tests for CouponService, PrismaCouponRepository, and couponRouter (already partially done).
- [x] Final pass: Remove any remaining legacy code, ensure all UI and forms use new APIs, and run full test/build.
- [x] All tests pass for all new parts of the architecture (bun test: 65 pass, 0 fail).
- [ ] Update documentation and diagrams for the new architecture. 

- Implemented getDaysUntilNextEvent in EventService, repository, and router. Updated HeroSection to use the new endpoint.
- All UI and forms now use the new APIs. All legacy code and references have been removed. 